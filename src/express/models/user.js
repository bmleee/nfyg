// Load the module dependencies
import mongoose from 'mongoose'
import crypto from 'crypto'
import { autoIncrement } from '../lib/db'

import ProjectModel from './project'
import ProductModel from './product'
import SponsorModel from './sponsor'
import PurchaseModel from './purchase'

import FacebookTracker from '../../lib/FacebookTracker'
import fetchDataByKey, { KEYS } from '../lib/fetchDataByKey'
import pick from 'lodash.pick'

import nodemailer from 'nodemailer';
import Q from 'q';
import uuid from 'node-uuid';

import bkfd2Password from 'pbkdf2-password'

export const access_levels = [0, 1, 5, 10, 100]

const Schema = mongoose.Schema;

// Define a new 'UserSchema'
const UserSchema = new Schema({
	id: { type: Number, required: false, unique: true }, // sequence number

	// only for facebook user
	fb_id: { type: String, trim: true },
	fb_access_token: { type: String, trim: true },

	salt: { type: String },

	name: { type: String, trim: true, }, // real name
	display_name: { type: String, required: false, trim: true },

	local_email: { type: String, trim: true, unique: true,
		// Validate the email format
		match: [/.+\@.+\..+/, "Please fill a valid email address"]
	},
	sub_email: { type: String },

	fb_email: { type: String, trim: true, unique: true,
		// Validate the email format
		match: [/.+\@.+\..+/, "Please fill a valid email address"]
	},

	/*
	 0 : nomal user
	 1 : artist, can publish / edit project, exhibition
	 10 : editor, can publish / edit magazine
	 100 : admin, can do anything
	 */
	access_level: { type: Number, default: 0, },
	// generated by hasher
	password: { type: String, },
	resetPasswordToken: { type: String, },
	resetPasswordExpires: { type: Date, },
	
	mail_check: {type: Boolean, default: false},
	mail_check_number: { type: String },
	mail_check_Expires: { type: Date },
	
	number_check: {type: Boolean, default: false},
	number_check_number: { type: String },
	number_check_Expires: { type: Date },

	image: {
		type: String,
		default: '/assets/images/user_default.png'
	},

	payments: [{ type: Schema.Types.ObjectId, ref: 'Payment' }],
	projects: [{ type: Schema.Types.ObjectId, ref: 'Project' }],
	products: [{ type: Schema.Types.ObjectId, ref: 'Project' }],
	stores: [{ type: Schema.Types.ObjectId, ref: 'Store' }],

	created_at: {type: Date, default: Date.now()},
	updated_at: {type: Date, default: Date.now()},

	intro: { type: String, },

	contact: { type: String, trim: true },
});

UserSchema.pre('update', function (next) {
	this.updated_at = Date.now()
	next()
})

// Configure the 'UserSchema' to use getters and virtuals when transforming to JSON
UserSchema.set('toJSON', {
	getters: true,
	virtuals: true
});

UserSchema.statics.findOneByEmail = function (email, cb) {
	return this.findOne({
		$or: [
			{fb_email: email},
			{local_email: email}
		]
	}, cb)
}

UserSchema.statics.findByNameOrEmail = function (email, display_name, cb) {
	return this.findOne({
		$or: [
			{local_email: email},
			{display_name: display_name}
		]
	}, cb)
}

UserSchema.statics.findByAppIds = function (fb_ids) {
	let re = new RegExp(fb_ids.join('|'), "i")
	return this.find({'fb_id': re})
}

UserSchema.methods.getUserType = function () {
	switch (this.access_level) {
		case 0: return 'user'
		case 1: return 'artist'
		case 5: return 'store'
		case 10: return 'editor'
		case 100: return 'admin'
	}
	throw new Error(`unknown user access level ${this.access_level}`)
}

UserSchema.methods.toFormat = async function(type, ...args) {
	switch (type) {
		case 'profile':
			const other = args[0] || false // show other user's profile
			return await _renderMyProfile(this, other)
		case 'userlist':
			return await _renderUserlist(this)
		case 'likelist':
			return await _renderLikelist(this)
		case 'profile_admin':
			return pick(this.toJSON(), ['id', 'fb_id', 'name', 'display_name', 'local_email', 'sub_email', 'fb_email', 'created_at'])
		case 'summary':
			let {
				project_names, likes, shares, comments
			} = await FacebookTracker.getUserSummary(this.id)
			let projects = await ProjectModel.findByNames(project_names)
			return {
				...pick(this.toJSON(), ['id', 'fb_id', 'name', 'display_name', 'local_email', 'sub_email', 'fb_email', 'created_at']),
				projects: projects.map(p => p.abstract)
			}
		case 'qnas':
			const other2 = args[0] || false
			return await _renderMyQnas(this, other2)
		default:
			throw new Error(`user to format can't accept type ${type}`)
	}
}

UserSchema.methods.supportedMoney = async function(project) {
	try {
		let [
			purchases
		] = await Promise.all([
			PurchaseModel.findByUserAndProject(this, project).select('purchase_info.amount')
		])

		const sum = (a, b) => a + b

		const purchaseMoney = purchases && purchases.reduce(sum, 0)

		return purchaseMoney || 0
	} catch (e) {
		console.error(e);
		return 0;
	}
};

UserSchema.methods.supportedMoneyOnProduct = async function(product) {
	try {
		let [
			purchases
		] = await Promise.all([
			PurchaseModel.findByUserAndProduct(this, product).select('purchase_info.amount')
		])
		
		let purchaseMoney = 0;
		for(var i in purchases){
			purchaseMoney += Number(purchases[i].purchase_info.amount);
		}
		
		return purchaseMoney
	} catch (e) {
		console.error(e);
		return 0;
	}
};

UserSchema.plugin(autoIncrement.plugin, { model: 'User', field: 'id' });

// Create the 'User' model out of the 'UserSchema'
const UserModel = mongoose.model('User', UserSchema);
export default UserModel

const _renderMyProfile = async (_this, other = false) => {
	try {
		let sharedProjects, purchasedProjects, authorizedProjects, authorizedProducts, authorizedStores, purchasedProducts, purchasedStores, likedProducts, likedProjects, products, stores, sponsors;

		if(other || _this.access_level === 0) { // normal user
			[ purchasedProjects, purchasedProducts, purchasedStores, authorizedProjects, authorizedProducts, authorizedStores, likedProducts, likedProjects ] = await fetchDataByKey({user: _this}, KEYS.purchasedProjects, KEYS.purchasedProducts, KEYS.purchasedStores, KEYS.authorizedProjects, KEYS.authorizedProducts, KEYS.authorizedStores, KEYS.likedProducts, KEYS.likedProjects)
		} else if (_this.access_level === 1) { // artist
			[ sharedProjects, purchasedProjects, purchasedProducts, authorizedProjects, authorizedProducts ] = await fetchDataByKey({user: _this}, KEYS.sharedProjects, KEYS.purchasedProjects, KEYS.purchasedProducts, KEYS.authorizedProjects, KEYS.authorizedProducts)
		} else if (_this.access_level === 5) { // store
			[ purchasedProducts, authorizedProducts, purchasedStores, authorizedStores, likedProducts ] = await fetchDataByKey({user: _this}, KEYS.purchasedProducts, KEYS.authorizedProducts, KEYS.purchasedStores, KEYS.authorizedStores, KEYS.likedProducts)
		} else if (_this.access_level === 10) { // editor
			[ sharedProjects, purchasedProjects, purchasedProducts, products ] = await fetchDataByKey({user: _this}, KEYS.sharedProjects, KEYS.purchasedProjects, KEYS.purchasedProducts, KEYS.products)
		} else if (_this.access_level === 100) { // admin
			[ products, stores ] = await fetchDataByKey({user: _this}, KEYS.products, KEYS.stores)
		} else {
			throw new Error(`[User ${_this.id}] has unknown access level ${_this.access_level}`)
		}

		return {
			user: pick(_this.toJSON(), ['id', 'name', 'display_name', 'image']),
			project: {
				sharedProjects,
				purchasedProjects,
				authorizedProjects,
				likedProjects
			},
			product: {
				purchasedProducts,
				authorizedProducts,
				likedProducts
			},
			store: {
				purchasedStores,
				authorizedStores
			},
			products,
			stores
		}
	} catch (e) {
		console.error(e);
	}
	throw new Error(`[User ${_this.id}] No such access level ${_this.access_level}`)
}


const _renderLikelist = async (_this) => {
	try {
		let likedProducts, likedProjects, likedStores;

		if(_this.access_level === 0) { // normal user
			[ likedProducts, likedProjects, likedStores ] = await fetchDataByKey({user: _this}, KEYS.likedProducts, KEYS.likedProjects, KEYS.likedStores)
		} else if (_this.access_level === 1) { // artist
			[ likedProducts, likedProjects, likedStores ] = await fetchDataByKey({user: _this}, KEYS.likedProducts, KEYS.likedProjects, KEYS.likedStores)
		} else if (_this.access_level === 5) { // store
			[ likedProducts, likedProjects, likedStores ] = await fetchDataByKey({user: _this}, KEYS.likedProducts, KEYS.likedProjects, KEYS.likedStores)
		} else if (_this.access_level === 10) { // editor
			[ likedProducts, likedProjects, likedStores ] = await fetchDataByKey({user: _this}, KEYS.likedProducts, KEYS.likedProjects, KEYS.likedStores)
		} else if (_this.access_level === 100) { // admin
			[ likedProducts, likedProjects, likedStores ] = await fetchDataByKey({user: _this}, KEYS.likedProducts, KEYS.likedProjects, KEYS.likedStores)
		} else {
			throw new Error(`[User ${_this.id}] has unknown access level ${_this.access_level}`)
		}

		return {
			user: pick(_this.toJSON(), ['id', 'name', 'display_name', 'image']),
			project: {
				likedProjects
			},
			product: {
				likedProducts
			},
			store: {
				likedStores
			}
		}
	} catch (e) {
		console.error(e);
	}
	throw new Error(`[User ${_this.id}] No such access level ${_this.access_level}`)
}

const _renderUserlist = async (_this) => {
	try {
		let userlist;

		if (_this.access_level === 100) { // admin
			[ userlist ] = await fetchDataByKey({user: _this}, KEYS.users)
		} else {
			throw new Error(`[User ${_this.id}] has unknown access level ${_this.access_level}`)
		}

		return {
			user: pick(_this.toJSON(), ['id', 'name', 'display_name', 'image']),
			userlist
		}
	} catch (e) {
		console.error(e);
	}
	throw new Error(`[User ${_this.id}] No such access level ${_this.access_level}`)
}

const _renderMyQnas = async (_this, other = false) => {
	try {
		let contactQnas, qnas, storeQnas, productQnas;

		if(other || _this.access_level === 0) { // normal user
			[ contactQnas, storeQnas, productQnas ] = await fetchDataByKey({user: _this}, KEYS.contactQnas, KEYS.storeQnas, KEYS.productQnas )
		} else if (_this.access_level === 1) { // artist
			[ contactQnas, productQnas ] = await fetchDataByKey({user: _this}, KEYS.contactQnas, KEYS.productQnas )
		} else if (_this.access_level === 5) { // store
			[ contactQnas, storeQnas, productQnas ] = await fetchDataByKey({user: _this}, KEYS.contactQnas, KEYS.storeQnas, KEYS.productQnas )
		} else if (_this.access_level === 10) { // editor
			[ contactQnas, productQnas ] = await fetchDataByKey({user: _this}, KEYS.contactQnas, KEYS.productQnas )
		} else if (_this.access_level === 100) { // admin
			[ qnas ] = await fetchDataByKey({user: _this}, KEYS.qnas)
		} else {
			throw new Error(`[User ${_this.id}] has unknown access level ${_this.access_level}`)
		}

		return {
			contactQnas,
			storeQnas,
			productQnas,
			qnas
		}
		
	} catch (e) {
		console.error(e);
	}
	throw new Error(`[User ${_this.id}] No such access level ${_this.access_level}`)
}

// helper
const _getSharedProjects = async (_this) => {
	const { project_names } = await FacebookTracker.getUserSummary(_this.id)
	return await ProjectModel.findByNames(project_names)
}
