// Load the module dependencies
import mongoose from 'mongoose'
import crypto from 'crypto'
import { autoIncrement } from '../lib/db'

import ProjectModel from './project'
import ProductModel from './product'
import SponsorModel from './sponsor'
import PurchaseModel from './purchase'

import FacebookTracker from '../../lib/FacebookTracker'
import pick from 'lodash.pick'

export const access_levels = [0, 1, 10, 100]

const Schema = mongoose.Schema;

// Define a new 'UserSchema'
const UserSchema = new Schema({
	id: { type: Number, required: true, unique: true }, // sequence number

	// only for facebook user
	fb_id: { type: String, trim: true },
	fb_access_token: { type: String, trim: true },

	salt: { type: String },

	name: { type: String, trim: true, }, // real name
	display_name: { type: String, required: true, trim: true },

	local_email: { type: String, unique: true, trim: true,
		// Validate the email format
		match: [/.+\@.+\..+/, "Please fill a valid email address"]
	},
	fb_email: { type: String, unique: true, trim: true,
		// Validate the email format
		match: [/.+\@.+\..+/, "Please fill a valid email address"]
	},

	/*
	 0 : nomal user
	 1 : artist, can publish / edit project, exhibition
	 10 : editor, can publish / edit magazine
	 100 : admin, can do anything
	 */
	access_level: { type: Number, default: 0, },
	// generated by hasher
	password: { type: String, },

	image: {
		type: String,
		default: '/assets/images/user_default.png'
	},

	payments: [{ type: Schema.Types.ObjectId, ref: 'Payment' }],
	projects: [{ type: Schema.Types.ObjectId, ref: 'Project' }],
	products: [{ type: Schema.Types.ObjectId, ref: 'Project' }],

	created_at: {type: Date, default: Date.now()},
	updated_at: {type: Date, default: Date.now()},

});

UserSchema.pre('update', function (next) {
	this.updated_at = Date.now()
	next()
})

// Configure the 'UserSchema' to use getters and virtuals when transforming to JSON
UserSchema.set('toJSON', {
	getters: true,
	virtuals: true
});

UserSchema.statics.findOneByEmail = function (email, cb) {
	return this.findOne({
		$or: [
			{fb_email: email},
			{local_email: email}
		]
	}, cb)
}

UserSchema.methods.getUserType = function () {
	switch (this.access_level) {
		case 0: return 'user'
		case 1: return 'artist'
		case 10: return 'editor'
		case 100: return 'admin'
		default: throw new Error(`unknown user access level ${this.access_level}`)
	}
}

UserSchema.methods.toFormat = async function(type, ...args) {
	switch (type) {
		case 'profile':
			const other = args[0] || false // show other user's profile
			return await _renderMyProfile(this, other)
		case 'profile_admin':
			return pick(this.toJSON(), ['id', 'fb_id', 'name', 'display_name', 'local_email', 'fb_email'])
		default:
			throw new Error(`user to format can't accept type ${type}`)
	}
}

UserSchema.methods.supportedMoney = async function({projectName, productName}) {
	try {
		let [
			purchases,
			shares
		] = await Promise.all([
			PurchaseModel.findByUser(this),
			FacebookTracker.getUserSummaryOnProject(this.id, projectName || productName),
		])

		const sum = (a, b) => a + b

		return purchases.map(p => p.purchase_info.amount).reduce(sum) +
			shares.map(s => 1000 + 200 * (s.comments + s.shares + s.likes)).reduce(sum)
	} catch (e) {
		console.error(e);
		return 0;
	}
};

UserSchema.plugin(autoIncrement.plugin, { model: 'User', field: 'id' });

// Create the 'User' model out of the 'UserSchema'
const UserModel = mongoose.model('User', UserSchema);
export default UserModel

// Helperfunctions
/*
	admin.profile: {
		projects,
		products,
		users,
		sponsors,
	},

	artist.profile: {
		project: {
			sharedProjects: [],
			purchasedProjects: [],
			authorizedProjects: [],
		},
		project: {
			purchasedProducts: []
		}
	}

	user.profile: {
		project: {
			sharedProjects: [],
			purchasedProjects: [],
		},
		product: {
			purchasedProducts: []
		}
	}
*/
const _renderMyProfile = async (_this, other = false) => {
	try {
		const [
			{project_names},
			purchases,
		] = await Promise.all([
			FacebookTracker.getUserSummary(_this.id),
			PurchaseModel.findDetailByUser(_this)
		])

		const _data = {
			sharedProjects: null,
			purchasedProjects: null,
			purchasedProducts: null,
			authorizedProjects: null,
			users: null,
			projects: null,
			products: null,
			sponsors: null,
		}
		const _fetcher = {
			sharedProjects: async () => await Promise.all(
				(await ProjectModel.findByNames(project_names))
					.map(async (p) => await p.toFormat('shared_project'))),
			purchasedProjects: async () => await Promise.all(
				purchases
					.filter(p => !!p.project)
					.map(async (p) => await p.toFormat('profile'))),
			purchasedProducts: async () => await Promise.all(
				purchases
					.filter(p => !!p.product)
					.map(async (p) => await p.toFormat('profile'))),
			authorizedProjects: async () => await Promise.all(
				(await ProjectModel.findAuthorizedOnesToUser(_this))
					.map(async (p) => await p.toFormat('profile_admin'))),
			users: async () => await Promise.all(
				(await UserModel.find({}))
					.map(async (u) => await u.toFormat('profile_admin'))
			),
			projects: async () => await Promise.all(
				(await ProjectModel.find({}))
					.map(async (p) => await p.toFormat('profile_admin'))
			),
			products: async () => await Promise.all(
				(await ProductModel.find({}))
					.map(async (p) => await p.toFormat('profile_admin'))
			),
			sponsors: async () => await Promise.all(
				(await SponsorModel.find({}))
					.map(async (p) => await p.toFormat('profile_admin'))
			),
		}

		if (other) { // otehr user's profile!
			let keys = ['sharedProjects',]

			let [
				sharedProjects,
			] = await Promise.all(keys.map(
				async (k) => await _fetcher[k]()
			))

			return {
				project: {
					sharedProjects,
				},
			}
		}

		let keys = []
		let ret = {}

		if (_this.access_level === 0) { // normal user
			keys = ['sharedProjects', 'purchasedProjects', 'purchasedProducts']
		} else if (_this.access_level === 1) { // artist
			keys = ['sharedProjects', 'purchasedProjects', 'purchasedProducts', 'authorizedProjects']
		} else if (_this.access_level === 10) { // editor
			keys = ['sharedProjects', 'purchasedProjects', 'purchasedProducts', 'projects', 'products',]
		} else if (_this.access_level === 100) { // admin
			keys = ['projects', 'products', 'users', 'sponsors']
		} else {
			throw new Error(`[User ${_this.id}] has unknown access level ${_this.access_level}`)
		}

		await Promise.all(keys.map(
			async (k) => ret[k] = await _fetcher[k]()
		))

		return {
			project: {
				sharedProjects: ret.sharedProjects,
				purchasedProjects: ret.purchasedProjects,
				authorizedProjects: ret.authorizedProjects,
			},
			product: {
				purchasedProducts: ret.purchasedProducts,
			},
			projects: ret.projects,
			products: ret.products,
			users: ret.users,
			sponsors: ret.sponsors,
		}
	} catch (e) {
		console.error(e);
	}
	throw new Error(`[User ${_this.id}] No such access level ${_this.access_level}`)
}

// helper
const _getSharedProjects = async (_this) => {
	const { project_names } = await FacebookTracker.getUserSummary(_this.id)
	return await ProjectModel.findByNames(project_names)
}
