// Load the module dependencies
import mongoose from 'mongoose'
import crypto from 'crypto'
import { autoIncrement } from '../lib/db'

import ProjectModel from './project'
import ProductModel from './product'
import SponsorModel from './sponsor'
import PurchaseModel from './purchase'

import FacebookTracker from '../../lib/FacebookTracker'
import fetchDataByKey, { KEYS } from '../lib/fetchDataByKey'
import pick from 'lodash.pick'

export const access_levels = [0, 1, 10, 100]

const Schema = mongoose.Schema;

// Define a new 'UserSchema'
const UserSchema = new Schema({
	id: { type: Number, required: true, unique: true }, // sequence number

	// only for facebook user
	fb_id: { type: String, trim: true },
	fb_access_token: { type: String, trim: true },

	salt: { type: String },

	name: { type: String, trim: true, }, // real name
	display_name: { type: String, required: true, trim: true },

	local_email: { type: String, trim: true,
		// Validate the email format
		match: [/.+\@.+\..+/, "Please fill a valid email address"]
	},
	fb_email: { type: String, trim: true,
		// Validate the email format
		match: [/.+\@.+\..+/, "Please fill a valid email address"]
	},

	/*
	 0 : nomal user
	 1 : artist, can publish / edit project, exhibition
	 10 : editor, can publish / edit magazine
	 100 : admin, can do anything
	 */
	access_level: { type: Number, default: 0, },
	// generated by hasher
	password: { type: String, },

	image: {
		type: String,
		default: '/assets/images/user_default.png'
	},

	payments: [{ type: Schema.Types.ObjectId, ref: 'Payment' }],
	projects: [{ type: Schema.Types.ObjectId, ref: 'Project' }],
	products: [{ type: Schema.Types.ObjectId, ref: 'Project' }],

	created_at: {type: Date, default: Date.now()},
	updated_at: {type: Date, default: Date.now()},

});

UserSchema.pre('update', function (next) {
	this.updated_at = Date.now()
	next()
})

// Configure the 'UserSchema' to use getters and virtuals when transforming to JSON
UserSchema.set('toJSON', {
	getters: true,
	virtuals: true
});

UserSchema.statics.findOneByEmail = function (email, cb) {
	return this.findOne({
		$or: [
			{fb_email: email},
			{local_email: email}
		]
	}, cb)
}

UserSchema.methods.getUserType = function () {
	switch (this.access_level) {
		case 0: return 'user'
		case 1: return 'artist'
		case 10: return 'editor'
		case 100: return 'admin'
	}
	throw new Error(`unknown user access level ${this.access_level}`)
}

UserSchema.methods.toFormat = async function(type, ...args) {
	switch (type) {
		case 'profile':
			const other = args[0] || false // show other user's profile
			return await _renderMyProfile(this, other)
		case 'profile_admin':
			return pick(this.toJSON(), ['id', 'fb_id', 'name', 'display_name', 'local_email', 'fb_email', 'created_at'])
		case 'summary':
			let {
				project_names, likes, shares, comments
			} = await FacebookTracker.getUserSummary(this.id)
			let projects = await ProjectModel.findByNames(project_names)
			return {
				...pick(this.toJSON(), ['id', 'fb_id', 'name', 'display_name', 'local_email', 'fb_email', 'created_at']),
				projects: projects.map(p => p.abstract)
			}
		default:
			throw new Error(`user to format can't accept type ${type}`)
	}
}

UserSchema.methods.supportedMoney = async function({projectName, productName}) {
	try {
		let [
			purchases,
			{
				shares,
				likes,
				comments,
				posts,
			},
		] = await Promise.all([
			PurchaseModel.find({user: this})
				.select('purchase_info.amount'),
			FacebookTracker.getUserSummaryOnProject(this.id, projectName || productName),
		])

		const sum = (a, b) => a + b

		const purchaseMoney = purchases && purchases.reduce(sum, 0)
		const shareMoney = 1000 * (posts && posts.length) + 200 * (shares + likes, comments)

		return (purchaseMoney || 0) + (shareMoney || 0)
	} catch (e) {
		console.error(e);
		return 0;
	}
};

UserSchema.plugin(autoIncrement.plugin, { model: 'User', field: 'id' });

// Create the 'User' model out of the 'UserSchema'
const UserModel = mongoose.model('User', UserSchema);
export default UserModel

// Helperfunctions
/*
	admin.profile: {
		projects,
		products,
		users,
		sponsors,
	},

	artist.profile: {
		project: {
			sharedProjects: [],
			purchasedProjects: [],
			authorizedProjects: [],
		},
		product: {
			purchasedProducts: [],
			authorizedProducts: []
		}
	}

	user.profile: {
		project: {
			sharedProjects: [],
			purchasedProjects: [],
		},
		product: {
			purchasedProducts: []
		}
	}
*/
const _renderMyProfile = async (_this, other = false) => {
	try {
		let sharedProjects, purchasedProjects, authorizedProjects, authorizedProducts, purchasedProducts, projects, products, users, sponsors;

		if(other || _this.access_level === 0) { // normal user
			[ sharedProjects, purchasedProjects, purchasedProducts ] = await fetchDataByKey({user: _this}, KEYS.sharedProjects, KEYS.purchasedProjects, KEYS.purchasedProducts)
		} else if (_this.access_level === 1) { // artist
			[ sharedProjects, purchasedProjects, purchasedProducts, authorizedProjects, authorizedProducts ] = await fetchDataByKey({user: _this}, KEYS.sharedProjects, KEYS.purchasedProjects, KEYS.purchasedProducts, KEYS.authorizedProjects, KEYS.authorizedProducts)
		} else if (_this.access_level === 10) { // editor
			[ sharedProjects, purchasedProjects, purchasedProducts, projects, products ] = await fetchDataByKey({user: _this}, KEYS.sharedProjects, KEYS.purchasedProjects, KEYS.purchasedProducts, KEYS.projects, KEYS.products)
		} else if (_this.access_level === 100) { // admin
			[ projects, products, users, sponsors ] = await fetchDataByKey({user: _this}, KEYS.projects, KEYS.products, KEYS.users, KEYS.sponsors)
		} else {
			throw new Error(`[User ${_this.id}] has unknown access level ${_this.access_level}`)
		}

		return {
			user: pick(_this.toJSON(), ['id', 'name', 'display_name', 'image']),
			project: {
				sharedProjects,
				purchasedProjects,
				authorizedProjects,
			},
			product: {
				purchasedProducts,
				authorizedProducts
			},
			projects,
			products,
			users,
			sponsors,
		}
	} catch (e) {
		console.error(e);
	}
	throw new Error(`[User ${_this.id}] No such access level ${_this.access_level}`)
}

// helper
const _getSharedProjects = async (_this) => {
	const { project_names } = await FacebookTracker.getUserSummary(_this.id)
	return await ProjectModel.findByNames(project_names)
}
